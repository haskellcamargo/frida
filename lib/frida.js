// Generated by LiveScript 1.3.1
var library, special, Context, Variable, tokenize, objectize, parenthesize, categorize, parse, objectMapper, interpret, interpretList, slice$ = [].slice;
library = require("./stdlib");
special = require("./core");
Context = (function(){
  Context.displayName = 'Context';
  var prototype = Context.prototype, constructor = Context;
  function Context(scope, parent){
    true;
    this.scope = scope;
    this.parent = parent;
  }
  prototype.get = function(ident){
    if (ident in this.scope) {
      return this.scope[ident];
    } else {
      return this.parent.get(ident);
    }
  };
  prototype.set = function(ident, val){
    if (this.parent === undefined) {
      return this.scope[ident] = val;
    } else {
      return this.parent.set(ident, val);
    }
  };
  return Context;
}());
Variable = (function(){
  Variable.displayName = 'Variable';
  var prototype = Variable.prototype, constructor = Variable;
  function Variable(type, val){
    true;
    this.type = type;
    this.val = val;
  }
  return Variable;
}());
tokenize = function(input){
  var o, i, ref, i$, to$, j, t;
  o = input.replace(/\\"/g, "!dquote!").replace(/\s+' '\s+/g, "'!space!'").split(/"/).map(function(x, y){
    if (i % 2 === 0) {
      return x.replace(/\-\-.*(\n|\z)/, '').replace(/\(/g, ' ( ').replace(/\)/g, ' ) ').replace(/\{/g, ' { ').replace(/\}/g, ' } ').replace(/:/g, ' : ');
    } else {
      return x.replace(/\s/g, "!space!");
    }
  }).join('"').trim().split(/\s+/).map(function(x){
    return x.replace(/!space!/g, " ").replace(/!dquote!/g, '\\"').replace(/!squote!/g, "\\'");
  });
  i = 1;
  ref = o.slice(1);
  for (i$ = 0, to$ = ref.length; i$ <= to$; ++i$) {
    j = i$;
    t = ref[j];
    switch (j) {
    case '(':
      i++;
      if (i === 1) {
        o.unshift('(');
        o.push(')');
        break;
      }
      break;
    case ')':
      i--;
    }
  }
  return o;
};
objectize = function(input, object, key){
  var token;
  object == null && (object = {});
  key == null && (key = true);
  token = input.shift();
  if (token === '}') {
    return categorize(object);
  } else if (key) {
    object[categorize(token).value] = objectize(input, object, false);
    return objectize(input, object, true);
  } else {
    if (token === '(') {
      return parenthesize(token);
    } else {
      return categorize(token);
    }
  }
};
parenthesize = function(input, list){
  var token;
  list == null && (list = []);
  token = input.shift();
  switch (token) {
  case undefined:
    return list.pop();
  case '(':
    list.push(parenthesize(input));
    return parenthesize(input, list);
  case ')':
    return list;
  case '{':
    list.push(objectize(input));
    return parenthesize(input, list);
  default:
    return parenthesize(input, list.concat(categorize(token)));
  }
};
categorize = function(input){
  if (!isNaN(parseFloat(input))) {
    return new Variable("literal", parseFloat(input));
  } else if (input[0] === '"' && input.slice(-1 === '"')) {
    return new Variable("literal", eval(input));
  } else if (input[0] === "'" && input.slice(-1 === "'")) {
    return new Variable("literal", slice$.call(input, 1, -2 + 1 || 9e9));
  } else if (input instanceof Object) {
    return new Variable('dict', input);
  } else {
    return new Variable('identifier', input);
  }
};
parse = function(input){
  return parenthesize(tokenize(input));
};
objectMapper = function(obj, fn){
  var i$, ref$, len$, v, results$ = [];
  for (i$ = 0, len$ = (ref$ = Object.getOwnPropertyNames(obj)).length; i$ < len$; ++i$) {
    v = ref$[i$];
    results$.push(fn(v));
  }
  return results$;
};
interpret = function(input, context){
  context == null && (context = new Context(library));
  if (input instanceof Array) {
    return interpretList(input, context);
  } else if (input.type === "identifier") {
    return context.get(input.value);
  } else if (input.type === "dict") {
    objectMapper(input.value, function(x){
      return input.value[x] = interpret(input.value[x]);
    });
    return input.value;
  } else {
    return input.value;
  }
};
interpretList = function(input, context){
  var list;
  if (input.length === 0) {
    return;
  }
  if (input[0].value in special) {
    return special[input[0].value](input, context);
  } else {
    list = input.map(function(x){
      return interpret(x, context);
    });
    if (list[0] instanceof Function) {
      return list[0](list.slice(1));
    } else {
      return list;
    }
  }
};
exports.interpret = interpret;
exports.parse = parse;
exports.tokenize = tokenize;
exports.Context = Context;
exports.Variable = Variable;