// Generated by LiveScript 1.3.1
var fs, repl, frida, syn, args, argv, code, context, cmdc, cmdln;
fs = require('fs');
repl = require('repl');
frida = require('../compiler/frida');
syn = require('../compiler/syn');
args = require('optimist').usage("Usage: $0 -vlp [filename]").describe("p", "prints parsed code and exits").describe("v", "prints the version and exits").describe("h", "prints this help and exits").describe("l", "uses util.inspect for return values instead of syntax" + "converter for REPL");
argv = args.argv;
if (argv.h) {
  args.showHelp();
  process.exit();
}
if (argv.v) {
  console.log("frida " + require("../package.json").version);
  process.exit();
}
if (argv._.length > 0) {
  code = fs.readFileSync(argv._[0], {
    encoding: 'utf8'
  });
  if (!argv.p) {
    frida.interpret(frida.parse(code));
  } else {
    console.log(frida.parse(code));
  }
} else {
  context = new frida.Context;
  cmdc = 0;
  cmdln = "";
  repl.start({
    prompt: "frida> ",
    "eval": function(cmd, context, filename, callbac){
      if (cmd !== "(\n)") {
        cmd = cmd.slice(1, -1);
        cmdc += syn.verify(frida.tokenize(cmd));
        if (cmdc < 0) {
          process.exit();
        }
        if (cmdc !== 0) {
          cmdln += cmd;
          return callback(cmdc);
        } else if (!argv.p) {
          cmd = cmdln + cmd;
          cmdln = "";
          return argv.l
            ? callback(null, frida.interpret(frida.parse(cmd, context)))
            : "=> " + syn.convert(frida.interpret(frida.parse(cmd, context)));
        } else {
          return callback(null, frida.parse(cmd));
        }
      } else {
        return callback(null, cmdc > 0 ? cmdc : void 8);
      }
    }
  });
}